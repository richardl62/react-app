// In array elements the 'real' name cone first.  The other elements are aliases.
const rankNames = ['ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king']
const suitNames = ['club', 'diamond', 'heart', 'spade'];
const jokerName = 'joker';

const numRanks = rankNames.length;
const numSuits = suitNames.length;
const deckSize = numRanks * numSuits; // Excluded Jokers

class CoreCard {
    // Requires an id as generated by fullPack() or makeJoker();
    constructor(id) {
        if(!(Number.isInteger(id) && id >= 0))
        {
            throw Error(`${id} is not a valid card ID`);
        }

        this._id = id;
        Object.freeze(this); 
    }

    copy() {
        return new CoreCard(this._id);
    }

    id() {
        return this._id;
    }

    isJoker() { return this._id >= deckSize; }

    suitIndex() {
        if(this.isJoker()) {
            throw Error("Cannot can suit of joker");
        }
        
        return Math.floor(this._id/numRanks);
    }

    rankIndex() {
        if(this.isJoker()) {
            throw Error("Cannot can rank of joker");
        }
        
        return this._id % numRanks;
    }

    suitName() {
        return suitNames[this.suitIndex()];
    }

    rankName() {
        return rankNames[this.rankIndex()];
    }

    name() {
        const id = this._id;

        if (id >= deckSize) {
            return `${jokerName}-${id + 1 - deckSize}`;
        } else {
            return `${this.suitName()}-${this.rankName()}`;
        }
    }
}

function fullPack() {
    let cards = [];
    for (let i = 0; i < deckSize; ++i) {
        cards.push(new CoreCard(i));
    }
    return cards;
}

function makeJoker(jokerNumber) {
    return new CoreCard(deckSize + jokerNumber);
}

export { CoreCard, fullPack, makeJoker };
