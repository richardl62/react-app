// In array elements the 'real' name cone first.  The other elements are aliases.
const rankNames = ['ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king']
const suitNames = ['club', 'diamond', 'heart', 'spade'];
const jokerName = 'joker';

const numRanks = rankNames.length;
const numSuits = suitNames.length;
const deckSizeWithoutJokers = numRanks * numSuits;

const deckSize = 100; // allows for lot of jokers!

const cardSvgSet = require.context('./svgs', false, /\.svg$/);

// Make an array of svgs indexed by 'withinDeckId'
function makeSvgArray() {
    let svgs = [];
    for (let suit of suitNames) {
        const svgSuitName = suit.toUpperCase();
        for (let rankIndex = 1; rankIndex <= numRanks; ++rankIndex) {
            svgs.push(cardSvgSet(`./${svgSuitName}-${rankIndex}.svg`));
        }
    }

    return svgs;
}

const cardSvgs = makeSvgArray();
const jokerSvg = cardSvgSet('./JOKER-1.svg');
const cardBackSvg = cardSvgSet('./BACK.svg');

class CoreCard {
    // Requires an id as generated by fullDeck() or makeJoker();
    constructor(id) {
        if(!(Number.isInteger(id) && id >= 0))
        {
            throw Error(`${id} is not a valid card ID`);
        }

        this._id = id;
        Object.freeze(this); 
    }

    copy() {
        return new CoreCard(this._id);
    }

    get id() { return this._id; }

    get deckId() { return Math.floor(this._id / deckSize); }

    get withinDeckId() { return this._id % deckSize;}

    get jokerNumber() { return this.withinDeckId - numRanks * numSuits;}

    get isJoker() { return this.jokerNumber >= 0;}

    get rankIndex() { return this.withinDeckId % numRanks;}

    get suitIndex() { return Math.floor(this.withinDeckId / numRanks);}

    get rankName() { return rankNames[this.rankIndex]; }

    get suitName()  { return suitNames[this.suitIndex]; }

    name() {
        if (this.isJoker) {
            return `${jokerName}-${this.jokerNumber}`;
        } else {
            return `${this.suitName}-${this.rankName}`;
        }
    }

    svg() {
        return this.isJoker ? jokerSvg : cardSvgs[this.withinDeckId];
    }

    static get backSvg() {
        return cardBackSvg;
    }
}


function sanityCheckCardId(cc) {  // cc -> coreCard

    let withinDeckId;
    if(cc.isJoker) {
        withinDeckId = deckSizeWithoutJokers + cc.jokerNumber;
    } else {
        withinDeckId = cc.rankIndex + cc.suitIndex * numRanks; 
    }

    const id = withinDeckId + cc.deckId * deckSize;

    if(id !== cc.id) {
        throw Error(`Problem with card id`)
    }
}

// All cards generated by a CardGenerator will have unique IDs.
class CoreCardGenerator {
    constructor() {
      this._deckId = 0;
      this._jokerNumber = 0;
    }
  
    deck() {
        const deckSize = numRanks * numSuits;

        let deck = Array(deckSize);
        for(let withinDeckId = 0; withinDeckId < deckSize; ++withinDeckId)
        {
            const id = withinDeckId + this._deckId * deckSize;
            const cc = new CoreCard(id);

            sanityCheckCardId(cc); // Temporary

            deck[withinDeckId] = cc;
        }

        ++this._deckId;
        this._jokerNumber = 0;

        return deck;
    }
  
    joker() {
        const withinDeckId = deckSizeWithoutJokers + this._jokerNumber;
        ++this._jokerNumber;

        const id = withinDeckId + this._deckId * deckSize;
        const cc = new CoreCard(id);
        sanityCheckCardId(cc); // Temporary

        return cc;
    }

    // Convenience functions
    decks(num) {
        let result = [];
        for(let i = 0; i < num; ++i) {
            result.push(...this.deck());
        }

        return result;
    }

    jokers(num) {
        let result = [];
        for(let i = 0; i < num; ++i) {
            result.push(this.joker());
        }

        return result;
    }
  };


export { CoreCard, CoreCardGenerator };
