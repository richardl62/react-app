// In array elements the 'real' name cone first.  The other elements are aliases.
const rankNames = ['ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king']
const suitNames = ['club', 'diamond', 'heart', 'spade'];
const jokerName = 'joker';

const numRanks = rankNames.length;
const numSuits = suitNames.length;
const maxDeckSize = 100; // allows for (a lot of) jokers

const CardSvgs = require.context('./svgs', false, /\.svg$/);
const suitNamesForSvgs = ['CLUB', 'DIAMOND', 'HEART', 'SPADE'];
const cardBackSvg = CardSvgs('./BACK.svg');

class CoreCard {
    // Requires an id as generated by fullDeck() or makeJoker();
    constructor(id) {
        if(!(Number.isInteger(id) && id >= 0))
        {
            throw Error(`${id} is not a valid card ID`);
        }

        this._id = id;
        Object.freeze(this); 
    }

    copy() {
        return new CoreCard(this._id);
    }

    get id() { return this._id; }

    get deckId() { return Math.floor(this._id / maxDeckSize); }

    get withinDeckId() { return this._id % maxDeckSize;}

    get jokerNumber() { return this.withinDeckId - numRanks * numSuits;}

    get isJoker() { return this.jokerNumber >= 0;}

    get rankIndex() { return this.withinDeckId % numRanks;}

    get suitIndex() { return Math.floor(this.withinDeckId / numRanks);}

    get rankName() { return rankNames[this.rankIndex]; }

    get suitName()  { return suitNames[this.suitIndex]; }

    name() {
        if (this.isJoker) {
            return `${jokerName}-${this.jokerNumber}`;
        } else {
            return `${this.suitName}-${this.rankName}`;
        }
    }

    svg() {
        let fileName;
        if (this.isJoker) {
            fileName = "JOKER-1";
        } else {
            const suit = suitNamesForSvgs[this.suitIndex];
            const index= this.rankIndex + 1;
            fileName = `${suit}-${index}`;
        }
    
        return CardSvgs(`./${fileName}.svg`);
    }
    static get backSvg() {
        return cardBackSvg;
    }
}


function sanityCheckCardId(cc) {  // cc -> coreCard

    let withinDeckId;
    if(cc.isJoker) {
        withinDeckId = numRanks * numSuits + cc.jokerNumber;
    } else {
        withinDeckId = cc.rankIndex + cc.suitIndex * numRanks; 
    }

    const id = withinDeckId + cc.deckId * maxDeckSize;

    if(id !== cc.id) {
        throw Error(`Problem with card id`)
    }
}

// All cards generated by a CardGenerator will have unique IDs.
class CoreCardGenerator {
    constructor() {
      this._deckId = 0;
      this._jokerNumber = 0;
    }
  
    deck() {
        const deckSize = numRanks * numSuits;

        let deck = Array(deckSize);
        for(let withinDeckId = 0; withinDeckId < deckSize; ++withinDeckId)
        {
            const id = withinDeckId + this._deckId * maxDeckSize;
            const cc = new CoreCard(id);

            sanityCheckCardId(cc); // Temporary

            deck[withinDeckId] = cc;
        }

        ++this._deckId;
        this._jokerNumber = 0;

        return deck;
    }
  
    joker() {
        const withinDeckId = maxDeckSize + this._jokerNumber;
        ++this._jokerNumber;

        const id = withinDeckId + this._deckId * maxDeckSize;
        const cc = new CoreCard(id);
        sanityCheckCardId(cc); // Temporary

        return cc;
    }

    // Convenience functions
    decks(num) {
        let result = [];
        for(let i = 0; i < num; ++i) {
            result.push(...this.deck());
        }

        return result;
    }

    jokers(num) {
        let result = [];
        for(let i = 0; i < num; ++i) {
            result.push(this.joker());
        }

        return result;
    }
  };


export { CoreCard, CoreCardGenerator };
